# 第2章 线性表
## 2.1 线性表的定义及ADT
线性表的规模或长度；空表；

第一次认识ADT。

给出了线性表的ADT，值得注意的是ADT和后面具体的存储结构实现无关（也就是无论是顺序存储还是链式存储都是这个ADT）。

基本操作可以分为5类：
1. 构造类initialize
2. 属性类isEmpty, length, isFull, get, find
3. 数据操纵类: insert, remove, clear
4. 遍历类
5. 典型应用类

## 2.2 线性表的顺序存储结构

任何一种数据结构在内存中的存储通常考虑顺序存储和链式存储。

顺序存储，物理顺序和逻辑顺序一样。

### 2.2.1 顺序表
基于数组实现。

数组下标0，`elem[0]`用作特殊用途，不存放顺序表的元素。因此从下标为1的数组元素开始连续地存储元素，换句话说，`elem[n]`就是顺序表的第`n`个元素。

这里书本P20有一张图解释了maxSize, initSize, len这些的关系。

len是当前的实际元素的个数，maxSize是存储空间的大小，也就是最多能存储多少元素的限制。

``` cpp
// 程序2-1 顺序表seqList及操作的定义
```

### 2.2.2 顺序表基本操作的实现
1. 查找操作
`elem[0]`用作**哨兵单元**，从尾向头反向查找。时间复杂度：`O(n)`

TODO： 上面的情况只考虑了待查找元素进出现0次或者1次的情况，设计一个count函数，统计参数出现次数。

2. 插入操作 insert

TODO：这里需要提到doubleSpace的具体操作来解释为什么平均的时间复杂度是O(n),但是具体的doubleSpace是在后面下面一点才提到的，有待改进

需要注意的是具体实现，先移动最后面的元素，否则会覆盖

3. 删除操作 remove

也是需要注意移动的顺序，先向前移动第一个需要移动的元素。顺序表最后一个元素移动到倒数第二个位置上后不需要其他操作，直接`len--`相当于舍弃了最后一个多余的元素（具体解释可以看书本P23）


``` cpp
// 程序2-2 顺序表基本操作的实现
```
一个简单的应用：
``` cpp
// 程序2-3 求两个正整数集合的交集
```


## 2.3 线性表的链式存储结构

分析顺序表的弊端：插入/删除都需要移动大量的元素，如果一段程序对于一个序列需要频繁插入或者删除的话就会效率低下，链式存储结构。

链表：采用链式存储（每个元素放在一个独立的存储单元，在元素上附加指针来表示元素间的逻辑关系）

节点：由元素值和指针组成的结构体变量（类的对象）。

从语言层面来看需要new和delete

首节点，第一个存放线性表元素的节点，顺次找出线性表中的所有节点。

通常设置头节点在首节点之前，并且用头指针head来指向头节点，好处是在首节点位置上的插入或者删除的操作和后续其他节点保持一致。

TODO：这里可以补充具体一点的例子说明为什么有这样的好处。下面这个格式需要调整

- 单链表中的头节点和首节点:

    在单链表的设计中，头节点 是一个特殊的节点，通常不存储实际数据，仅用于方便链表操作。首节点 则是存储线性表第一个有效元素的节点。设置头节点的主要目的是统一链表的操作逻辑，特别是在首节点插入和删除操作上，与后续节点的处理保持一致。

    示例解释：使用头节点的好处

    没有头节点的情况

    如果链表中没有头节点，首节点直接作为链表的起点。假设链表表示为：

    A → B → C → NULL

    头指针 head 指向 A。
        1.	插入操作
        •	在链表的中间位置插入一个节点时，例如在 B 后插入 X：

    Node* p = head;  // 遍历找到B
    while (p != NULL && p->data != 'B') {
        p = p->next;
    }
    Node* newNode = new Node('X');
    newNode->next = p->next;
    p->next = newNode;


        •	逻辑很直观，操作统一。
        •	问题：在首节点前插入一个节点（例如插入 Z 作为新的首节点），需要单独处理：

    Node* newNode = new Node('Z');
    newNode->next = head;
    head = newNode;  // 更新头指针

    这种情况的逻辑不同于普通节点的插入，必须额外考虑更新 head。

        2.	删除操作
        •	删除中间节点，例如 B：

    Node* p = head;
    while (p->next != NULL && p->next->data != 'B') {
        p = p->next;
    }
    Node* toDelete = p->next;
    p->next = p->next->next;
    delete toDelete;


        •	删除首节点 A，则需要单独处理：

    Node* toDelete = head;
    head = head->next;  // 更新头指针
    delete toDelete;

    有头节点的情况

    如果链表有头节点，链表看起来如下：

    HEAD → A → B → C → NULL

    头节点 HEAD 不存储任何数据，指针 head 指向 HEAD。
        1.	插入操作
        •	在链表的中间位置插入一个节点（例如在 B 后插入 X），逻辑与之前一致：

    Node* p = head->next;  // 从首节点开始遍历
    while (p != NULL && p->data != 'B') {
        p = p->next;
    }
    Node* newNode = new Node('X');
    newNode->next = p->next;
    p->next = newNode;


        •	在首节点前插入一个节点（例如 Z 作为新的首节点），逻辑也统一了：

    Node* newNode = new Node('Z');
    newNode->next = head->next;  // 头节点的 next 指向首节点
    head->next = newNode;


        2.	删除操作
        •	删除中间节点（例如 B），逻辑不变：

    Node* p = head;
    while (p->next != NULL && p->next->data != 'B') {
        p = p->next;
    }
    Node* toDelete = p->next;
    p->next = p->next->next;
    delete toDelete;


        •	删除首节点（例如 A），逻辑与删除中间节点一致：

    Node* toDelete = head->next;
    head->next = head->next->next;
    delete toDelete;


链表有节点构成，节点包含：数据字段和指针字段。

分类3类：
1. 单链表：每个节点一个指针字段next；如果最后一个节点的next指向头节点（TODO：我不理解为什么不是首节点，这里可以自己实现然后约瑟夫问题）
2. 双链表两个指针字段：prior和next，需要有特殊的头节点+尾节点。双向循环链表：头节点的prior指向尾节点，尾节点的next指向头节点。
3. 空链表：顾名思义，没有元素。


### 2.3.1 单链表

``` cpp
// 程序2-4 单链表(linkList.h)
```

TODO：可能需要补充关于`friend`的用法

头节点并不是线性表中的一部分。

### 2.3.2 单链表基本操作的实现

1. 插入操作：insert
基本原则：先构建好新的节点本身（数据，指针字段指向后继节点（这里是单链表只需要next）），然后在重新设置前面的节点的指针字段指向新节点。

2. 删除操作：remove
要记得释放被删除节点所占据的内存。

TODO：调整下面的表格格式，然后应该添加平均时间复杂度
顺序表 vs 单链表 操作时间复杂度对比

| 操作         | 顺序表（Array）               | 单链表（Singly Linked List）    |
| ------------ | ----------------------------- | ------------------------------- |
| **插入**     |                               |                                 |
| - 头部插入   | O(n) （需要移动所有元素）     | O(1) （直接修改头指针即可）     |
| - 中间插入   | O(n) （需要移动部分元素）     | O(n) （需遍历到插入位置）       |
| - 尾部插入   | O(1) （若容量足够，无需移动） | O(n) （需遍历到链表末尾）       |
| **删除**     |                               |                                 |
| - 头部删除   | O(n) （需要移动所有元素）     | O(1) （直接修改头指针即可）     |
| - 中间删除   | O(n) （需要移动部分元素）     | O(n) （需遍历到删除位置）       |
| - 尾部删除   | O(1) （若容量足够，无需移动） | O(n) （需遍历到倒数第二个节点） |
| **查找**     |                               |                                 |
| - 按索引查找 | O(1) （支持随机访问）         | O(n) （需从头遍历到目标位置）   |
| - 按值查找   | O(n) （需逐一比对）           | O(n) （需逐一比对）             |

---

 总结

1. **顺序表的优势**：
   - **随机访问快**：支持 O(1) 的按索引查找，适合需要频繁访问指定位置元素的场景。
   - **尾部插入和删除快**：当容量足够时，尾部插入和删除操作的时间复杂度为 O(1)。

2. **单链表的优势**：
   - **头部操作快**：头部插入和删除操作的时间复杂度为 O(1)，适合需要频繁修改链表头部的场景。
   - **灵活性强**：不需要预分配存储空间，大小可动态增长。

3. **共同的劣势**：
   - 对于按值查找，两者时间复杂度都是 O(n)，因为需要逐一比对每个元素。


``` cpp
// 程序2-5 单链表基本操作的实现
```

clear函数中p、q指针的“兄弟协同法”。

首席插入，速度最快O(1).

TODO：下面这个额需要调整格式，并且补充图示：
``` plaintext
head -> A -> B -> C -> D -> NULL
```

为了演示上面两个方法：
``` cpp
// 程序2-6 单链表就地逆置操作的实现
/**
    * 反转链表中的元素顺序。
    */
template <class elemType>
void LinkList<elemType>::reverse()
{
    Node<elemType> *prev = nullptr;
    Node<elemType> *current = head->next;
    while (current != nullptr)
    {
        Node<elemType> *nextNode = current->next;
        current->next = prev;
        prev = current;
        current = nextNode;
    }
    head->next = prev;
}
```

- 时间复杂度：O(n)
- 每个节点访问一次，反转其指针方向。
- 空间复杂度：O(1)
- 只使用了 prev、current 和 nextNode 三个额外指针，无需分配额外存储空间。




### 2.3.3 单向循环链表

需要参考PPT，约瑟夫环

### 2.3.4 双链表、双向循环链表

TODO: 需要补充

## 2.4 线性表的应用

总共三个应用，其中在书本上，2.4.2和2.4.3都是选做，PPT则只有2.4.2字符串是选做。

### 2.4.1 一元多项式的加法

这里书本上解释的很清楚。

### 2.4.2 字符串的存储和实现
TODO：下面都需要补充完整。

字符串和线性表相似但是也有差异，基本操作特殊性。

#### 基本概念
空串

空格串

单字符串

串相等

子串

主串

串的长度：只考虑字符数量，结束符不计入字符串长度。

举例

#### 存储

分析顺序和链式存储结构，单个字符1个字节，一个指针4个字节，顺序存储空间利用率更高。

静态存储和动态存储。

#### 基本操作

TODO：处理成markdown 表格的形式
特性	<cstring>	<string>
数据类型	C 风格字符串（char* 或字符数组）	C++ 标准库的 std::string
内存管理	手动管理	自动管理
操作难度	较低级，需注意内存操作安全性	高级，功能封装，易用
功能性	提供基本的字符串操作函数	支持丰富的成员函数和运算符重载
安全性	较低，容易发生越界或内存泄漏	较高，减少了内存管理和越界问题
性能	较高（直接操作内存）	略低（封装底层操作）
推荐使用场景	低级内存操作，C/C++ 兼容代码	现代 C++ 开发，动态字符串处理

我们仿照的是string面向对象。

具体实现代码参考`./include/SeqString.h`文件中的代码。

需要注意：s,t相互赋值是`s.str[i] = t.str[i]`，而不是`s.str=t.str`。

#### 模式匹配

1. Brute-Force BF
2. Knuth-Morris-Pratt KMP


### 2.4.3 稀疏矩阵

稀疏矩阵: 矩阵中的非零元素个数远远小于矩阵元素总数的矩阵。可以通过只存储非零元素和非零元素所在的位置来压缩，减少使用的空间。

用一个结构体三元组来记录非零元素：
``` cpp
struct triple {
    int row, col;
    int data;
};
```

具体实现请看代码。


## 2.5 小结
## 2.6 习题
### 书本
### PPT

TODO： 格式需要调整

1. .线性表若采用链式存储结构保存，则要求内存中可用存储单元的地址（  D  ）。

A．必须是连续的		B．部分地址必须是连续的
C．一定是不连续的	D．连续或不连续都可以

2. 将下列特性对应到顺序表和链表中，对号入座。
A．逻辑上相邻的元素，在内存中的存储位置也相邻
B．不必事先估计存储空间
C．所需空间与元素个数成正比
D．插入、删除时不需要移动元素
E．支持随机存取
F．支持顺序存取

顺序表具有的特性有：A、E和F。链表具有的特性有：B、C、D和F。

3. 如何查找单链表的中间节点？
- 已知长度len：  len为奇数即第len/2+1个，偶数有2个中间点取一个，如为第len/2
- 未知长度：遍历一遍，得到len， 后同A
- 未知长度：两个指针p和q，p一次走两步，q一次走一步，p为空时，q所指既是目标。

4. 设有一个正整数序列组成的有序单链表（按非递减次序有序，允许有相等的整数存在），
  试编写能实现下列功能的算法。
确定在序列中比正整数x大的数有几个（相同的数只计算一次，如序列 {4,5,7,7,8,10,11,15,15,16,17,20}中比10大的数有5个）；
将单链表中比正整数x小的数按递减次序重排，仍放置在单链表中；

5. 设线性表元素为整数，其中可能有相同的元素。试设计一个算法删除表中重复的元素（即相同元素只保留一个），使删除后表中各元素均不相同。给出在顺序存储和链式存储两种方式下的实现程序。
方法可以是：
有序时，可以和前一元素比较，效率？
无序时， 已知最大值，另外用一个标志数组，效率？
无序时，未知最大值，如何处理？效率？


### ACM-OJ

#### 2416

#### 2417

题目链接：[2417]()

题解：请看代码文件。

stl题解：
``` cpp
#include <iostream>
#include <unordered_map>

int main()
{
    int n;
    std::cin >> n;

    std::unordered_map<long long, int> freqMap;  // 使用哈希表存储数字及其频率
    int maxFreq = 0;                             // 最大频率

    for (int i = 0; i < n; i++) {
        long long num;
        std::cin >> num;

        freqMap[num]++;
        if (freqMap[num] > maxFreq) {
            maxFreq = freqMap[num];  // 更新最大频率
        }
    }

    std::cout << maxFreq << std::endl;
    return 0;
}
```
