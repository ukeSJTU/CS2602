# 第3章 栈和队列

本章要学习的栈和队列是时间有序表，由元素到达和离开线性结构的时间决定元素之间的关系。

栈和队列可以看作是插入和删除操作位置受限的线性表，其中：
1. 栈是限定仅在表尾进行插入和删除操作的线性表；
2. 队列是只允许在一端进行插入操作、另一段进行删除操作的线性表。

## 3.1 栈

LIFO或者FILO，后进先出，先进后出。

### 3.1.1 栈的定义和抽象数据类型

### 3.1.2 栈的顺序存储及实现


共享栈

双共享栈



### 3.1.3 栈的链式存储及实现

## 3.2 栈的应用

### 3.2.1 括号配对检查

简单分析算法：
1. 创建一个字符栈
2. 读入字符
3. 如果是开括号，将其进栈；如果是闭括号但栈为空，说明缺少开括号；如果是闭括号但栈不为空，出栈，看是否匹配
4. 继续
5. 当字符串结束的时候，栈如果仍然非空说明开括号多了。

### 3.2.2 表达式计算

## 3.3 队列

TODO：补充简单说明文字
FIFO 先进先出

队尾

队首

### 3.3.1 队列的定义及ADT

 TODO：调整格式例如入队(`enQueue`)，补充专有概念名词的英文
删除操作只能在队首`Front`进行，叫做出队dequeuue;插入操作只能队尾进行，入队

### 3.3.2 队列的顺序存储及实现

TODO：适当调整表达和格式，利用backticks包裹部分内容。

主要围绕如何利用front_p和rear_p的关系来判断队列为空/满，讨论队首指针front_p和队尾指针rear_p的具体设置。

**怎么判断队列为空？**

最容易想到的是front_p和rear_p分别指向实际队首/队尾元素的地址，但是问题显而易见：队列为空的时候front_p=rear_p=-1，此时入队一个元素，front_p=rear_p=0，可以发现我们没有办法利用front_p和rear_p的关系来判断队列是否为空。

解决办法：
1. front_p指向真正的队首元素，rear_p指向队尾元素的后一个数组单元。初始化时，front_p和rear_p都是0，入队元素后front_p保持0，rear_p向后移动变成1.这样front_p=rear_p就是队列为空；
2. front_p指向队首元素的前一个数组单元，rear_p指向真正的队尾元素；
3. 额外设立一个变量来标记当前队列是否为空。

其中方法1和方法2是类似的，方法3引入了额外的变量，暂不讨论。下面实现的代码全部基于方法1.


**队列满了该怎么办？**
TODO：下面的表述有待调整，最好可以补充一个简单的例子
经过一些列入队出队操作后，很有可能出现front_p和rear_p都指向数组的最后一个元素，那么如果想要再入队就会超过界限，可是这个时候整个数组前面又是空的（全部元素已经出队）。如果简单的将所有元素向数组左端移动浪费时间，这里提出**“循环技术”**。也就是说当rear_p已经指向数组的最后一个元素后，如果再入队，那么rear_p应该移动到数组开头0，也就是说并不总是简单的+1.

也正是因此，顺序存储的队列常称为**循环队列**。


### 3.3.3 队列的链式存储及实现

这个实现就很简单，考虑到不会在中间位置进行插入/删除操作，我们不需要设置头节点。front_p和rear_p分别指向实际的队首和队尾节点。当front_p=rear_p=nullptr的时候表明队列为空。

### 3.3.4 优先队列

什么是优先队列priority_queue: 进入队列的元素具有优先级，出队时按优先级顺序出队（优先级高的先出队）。

TODO: 补充两个例子说明什么情况下要用到优先队列。生活中各种事情的安排，先做优先级高的事情；计算机的任务调度等等。


具体实现：
如果用顺序存储的办法：当元素进队，直接放到队尾O(1)；当元素出队，遍历队列并找到优先级最高（也就是优先数最小的那个元素），出队（从数组中删除），为了避免数组中数据出现空，也为了避免整体移动后续所有元素，可以直接把队尾的元素移动到出队元素原本的位置上O(n)（主要消耗在寻找最小的优先数）。

如果用链式存储的办法：元素进队可以直接按照优先级排序，O(n)，出队就是和普通的队列一样，从队首取出元素O(1)。

时间复杂度分析：
TODO：需要一个markdown表格分别表示两种存储方法的出入队时间复杂度


## 3.4 队列的应用

## 3.5 小结

## 3.6 习题

### 书本

<details>
  <summary>2. 如果一个字母序列的入栈站顺序为 `abcd` ，且假设在进展的过程中，任何时候只要栈内有字母都可以选择出栈。则以下序列哪些不可能是出栈序列，为什么？<br/>(1)`dcba` (2)`badc` (3)`dbca` (4)`cabd` (5)`bacd` (6)`abcd` </summary>
  (1) 可行
  (2) 可行
  (3) 不可行
  (4) 不可行
  (5) 可行
  (6) 可行
</details>

> This should be a callout
> 
> Can I fold it

### PPT

### ACM-OJ

#### 1080

#### 14151

#### 2422