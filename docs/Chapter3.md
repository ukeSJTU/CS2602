# 第3章 栈和队列

本章要学习的栈和队列是时间有序表，由元素到达和离开线性结构的时间决定元素之间的关系。

栈和队列可以看作是插入和删除操作位置受限的线性表，其中：
1. 栈是限定仅在表尾进行插入和删除操作的线性表；
2. 队列是只允许在一端进行插入操作、另一段进行删除操作的线性表。

## 3.1 栈
栈(`Stack`)是限定仅在表尾进行插入和删除操作的线性表。

栈又称为后进先出(`Last In First Out`)的线性表，当然你也可以说它是`FILO(First In Last Out)`。

### 3.1.1 栈的定义和抽象数据类型

栈顶(`top`): 允许插入和删除操作的一端；

栈底(`botton`): 线性表的另一端；

空栈：不含任何数据元素的栈。

栈的插入操作：进栈，压栈，入栈。

栈的删除操作：出栈，弹栈。

构造类函数：`initialize`, `destroy`(这里应该指的就是析构函数); 属性操纵类: `isEmpty`, `isFull`, `top`; 数据操纵类: `push`, `pop`。 


### 3.1.2 栈的顺序存储及实现

简单分析一下top和bottom该怎么设置。bottom肯定一直是0，也就是栈底的位置。top如果是栈顶元素的下标，那么初始化的时候就是-1(也就是栈空的标志)。当top=maxSize-1的时候表示栈满。

另一种方案是top表示下一个元素进栈的位置。那么栈空就是top=bottom, 栈满就是top=maxSize, 这种方法更适合在同一个数组中存放两个或者更多的栈。

下面的实现(在一个数组中存放一个栈的时候)用第一种方法。


TODO: 调整下面关于（双）共享栈的内容：
共享栈总结笔记

共享栈的概念

共享栈是指多个栈共享同一块连续的内存空间，每个栈拥有一段独立的连续小空间，但整体上多个栈共享一个大的连续空间。
这种设计主要用于提高空间利用率，避免一些栈满而另一些栈空间未用的情况。

共享栈的特点
	1.	动态性：每个栈的大小可以根据实际的进栈和出栈动态变化。
	2.	高效性：通过共享空间减少内存浪费，提高空间使用率。
	3.	灵活性：栈的数量和分配方式可以灵活调整。

共享栈的条件

多栈共享空间
	•	假设有 m 个栈，栈的编号为 0, 1, ..., m-1。
	•	第 i 个栈空的条件：

top[i] = bottom[i]

表示栈顶指针与栈底指针相同。

	•	第 i 个栈栈满的条件：
	•	当 i < m-1 时：

top[i] = bottom[i+1]

表示第 i 个栈的栈顶到达了第 i+1 个栈的栈底。

	•	当 i = m-1 时：

top[i] = maxSize

表示第 m-1 个栈的栈顶到达了共享空间的末尾。

两个栈相向设置
	•	栈底：栈 0 的栈底设置在共享空间的起始位置，栈 1 的栈底设置在共享空间的末尾。
	•	栈顶：
	•	栈 0 的栈顶从左向右增长；
	•	栈 1 的栈顶从右向左增长。
	•	栈空的条件：

top[i] = bottom[i]  (i = 0 或 1)

表示两个栈可以独立为空。

	•	栈满的条件：

top[0] = top[1]

表示两个栈的栈顶相遇，空间仅剩一个单元无法被使用。

共享栈的优缺点

优点
	1.	提高空间利用率：多个栈共享空间，动态调整各栈的大小。
	2.	灵活性高：可根据需要调整栈的数量或空间分配策略。

缺点
	1.	实现复杂：需要额外的指针和逻辑处理各栈之间的共享关系。
	2.	浪费少量空间：当空间仅剩一个单元时无法使用。

应用场景
	•	在算法设计中需要多栈操作时（如表达式求值、分区处理）。
	•	多线程或多任务共享一块内存资源时，用于栈的管理。

时间复杂度分析：
都是O(1), `push`如果需要扩大空间那么就是O(n), 但是分摊到每次插入操作那么仍然是O(1).


### 3.1.3 栈的链式存储及实现

栈顶指针top就是单链表的首节点。

## 3.2 栈的应用

### 3.2.1 括号配对检查

简单分析算法：
1. 创建一个字符栈
2. 读入字符
3. 如果是开括号，将其进栈；如果是闭括号但栈为空，说明缺少开括号；如果是闭括号但栈不为空，出栈，看是否匹配
4. 继续
5. 当字符串结束的时候，栈如果仍然非空说明开括号多了。

### 3.2.2 表达式计算

需要注意，这一小节的讲解进行了一点假设：限定操作数是一位整数，运算符为加减乘除这四个二元运算符，括号仅有小括号，保证表达式合法。

TODO: 后面的内容需要补充，这里必须要围绕一个固定的数学表达式（要有代表性）展开讲解。

先简单讲解后缀表达式是什么，逆波兰，为什么需要（只要简单讲解）。后缀是因为所有的运算符号都出现在它所要计算的操作符后面。

然后研究如果已经知道了后缀表达式，该怎么计算结果。考虑用ascii字符画来讲解栈的变化。

然后就是我们人输入一般都是中缀表达式，怎么转化？

总结。


### 3.2.3 递归
这个是我自己补充的一点点内容。

递归调用与栈的关系

递归是一种函数调用自身的编程技巧。虽然看起来递归是直接调用自己，但在计算机内部，递归是通过 栈 来实现的。

当一个函数调用自身时，每一次调用都会将当前函数的状态（包括参数值、局部变量、返回地址等）压入栈中，以便在递归结束后能够回到上一次的调用点继续执行。这种机制叫做 调用栈。

举个例子：阶乘的递归计算

阶乘的公式是：
￼
递归实现：

int factorial(int n) {
    if (n == 1) return 1;          // 基本情况，递归终止
    return n * factorial(n - 1);   // 递归调用自身
}

当 factorial(5) 被调用时：
	1.	factorial(5) 调用 factorial(4)，将 5 的计算状态压入栈。
	2.	factorial(4) 调用 factorial(3)，将 4 的计算状态压入栈。
	3.	依次类推，直到 factorial(1) 返回结果。

栈中的内容会像这样（从栈底到栈顶）：

factorial(1) 返回 1
factorial(2) 等待 2 * factorial(1)
factorial(3) 等待 3 * factorial(2)
factorial(4) 等待 4 * factorial(3)
factorial(5) 等待 5 * factorial(4)

当 factorial(1) 返回 1 时，计算从栈顶开始回溯，逐层返回最终结果。

为什么是栈？
	•	栈是 后进先出（LIFO） 的数据结构。
	•	在递归中，最新的函数调用总是最先完成，因此使用栈非常合适。

小结

递归本质上依赖栈来保存每一层调用的上下文信息。如果没有栈，递归无法实现。理解这一点，不仅能帮助你掌握递归，还能帮助你理解函数调用的运行机制。

## 3.3 队列

队列(`Queue`)是只允许在一端进行插入操作、另一段进行删除操作的线性表。

队列又称为先进先出(`First In First Out`)的线性表.

### 3.3.1 队列的定义及ADT

队尾(`rear`): 允许插入的一端；

队首(`front`): 允许删除的一端；

入队(`enQueue`): 在队尾处插入新的元素；

出队(`deQueue`): 从队首处取出第一个元素；

### 3.3.2 队列的顺序存储及实现

TODO：适当调整表达和格式，利用backticks包裹部分内容。

主要围绕如何利用front_p和rear_p的关系来判断队列为空/满，讨论队首指针front_p和队尾指针rear_p的具体设置。

**怎么判断队列为空？**

最容易想到的是front_p和rear_p分别指向实际队首/队尾元素的地址，但是问题显而易见：队列为空的时候front_p=rear_p=-1，此时入队一个元素，front_p=rear_p=0，可以发现我们没有办法利用front_p和rear_p的关系来判断队列是否为空。

解决办法：
1. front_p指向真正的队首元素，rear_p指向队尾元素的后一个数组单元。初始化时，front_p和rear_p都是0，入队元素后front_p保持0，rear_p向后移动变成1.这样front_p=rear_p就是队列为空；
2. front_p指向队首元素的前一个数组单元，rear_p指向真正的队尾元素；
3. 额外设立一个变量来标记当前队列是否为空。

其中方法1和方法2是类似的，方法3引入了额外的变量，暂不讨论。下面实现的代码全部基于方法1.


**队列满了该怎么办？**
TODO：下面的表述有待调整，最好可以补充一个简单的例子
经过一些列入队出队操作后，很有可能出现front_p和rear_p都指向数组的最后一个元素，那么如果想要再入队就会超过界限，可是这个时候整个数组前面又是空的（全部元素已经出队）。如果简单的将所有元素向数组左端移动浪费时间，这里提出**“循环技术”**。也就是说当rear_p已经指向数组的最后一个元素后，如果再入队，那么rear_p应该移动到数组开头0，也就是说并不总是简单的+1.

也正是因此，顺序存储的队列常称为**循环队列**。


### 3.3.3 队列的链式存储及实现

这个实现就很简单，考虑到不会在中间位置进行插入/删除操作，我们不需要设置头节点。front_p和rear_p分别指向实际的队首和队尾节点。当front_p=rear_p=nullptr的时候表明队列为空。

### 3.3.4 优先队列

什么是优先队列priority_queue: 进入队列的元素具有优先级，出队时按优先级顺序出队（优先级高的先出队）。

TODO: 补充两个例子说明什么情况下要用到优先队列。生活中各种事情的安排，先做优先级高的事情；计算机的任务调度等等。


具体实现：
如果用顺序存储的办法：当元素进队，直接放到队尾O(1)；当元素出队，遍历队列并找到优先级最高（也就是优先数最小的那个元素），出队（从数组中删除），为了避免数组中数据出现空，也为了避免整体移动后续所有元素，可以直接把队尾的元素移动到出队元素原本的位置上O(n)（主要消耗在寻找最小的优先数）。

如果用链式存储的办法：元素进队可以直接按照优先级排序，O(n)，出队就是和普通的队列一样，从队首取出元素O(1)。

时间复杂度分析：
TODO：需要一个markdown表格分别表示两种存储方法的出入队时间复杂度


## 3.4 队列的应用

书本上这里提到了模拟银行业务，如果只有一个窗口，就是用一个普通的队列去模拟，遵循先到先服务的原则。具体代码请看`src/examples/Chapter3/banking/main.cpp`。

TODO：这个多窗口可能需要稍微更进一步的解释。
但是如果是多个窗口服务，就需要两个队列配合。等待区等候的孤苦形成一个普通队列，先来先服务，FIFO。各个窗口被服务的客户形成一个优先队列。

## 3.5 小结

- 栈虽然只是在线性表操作基础上限制了插入、删除的位置，使得插入、删除操作只能在表的同一个端点进行，可以看作是一种操作受限的线性表。
- 栈在计算机系统中是一种非常重要的数据结构。除了介绍的符号匹配、表达式计算，系统在函数调用、递归中都是以栈结构为基础。
- 栈有着非常独特的一组常见操作：进栈、出栈、求栈顶元素、判栈空、判栈满等。
- 在物理实现上虽然可以有顺序和链式两种存储方式，鉴于其操作都在一端进行，**顺序存储是栈最常使用的存储方式**。
- 队列可看作是限制了插入、删除操作位置的另外一种线性表，元素的插入、删除分别在表的两端进行。
- 除了日常生活中看到的实际队列可以用它来实现，计算机操作系统中许多对象的管理都利用了队列，如打印队列、进程队列等，因此它也是一种重要的数据结构。
- 队列的常见操作对照生活经验是最容易想到的：进队、出队、求队首元素、判空、判满等。
- 队列的顺序循环存储和链式存储的时间复杂度都是`O(1)`，考虑到链式存储每个结点额外的空间开销，**顺序循环队列是最常用的存储结构**。
- 优先队列不再按照先进先出的原则，优先级高者先出队。无论顺序还是链式优先队列，其进队、出队操作的时间复杂度为`O(1)`、`O(n)`或者`O(n)`、`O(1)`。
- 后面章节讨论过二叉树后，用二叉树作为工具存储优先队列时，时间复杂度能降到`O(log_2⁡n)`。




## 3.6 习题

### 书本

<details>
  <summary>2. 如果一个字母序列的入栈站顺序为 `abcd` ，且假设在进展的过程中，任何时候只要栈内有字母都可以选择出栈。则以下序列哪些不可能是出栈序列，为什么？<br/>(1)`dcba` (2)`badc` (3)`dbca` (4)`cabd` (5)`bacd` (6)`abcd` </summary>
  (1) 可行
  (2) 可行
  (3) 不可行
  (4) 不可行
  (5) 可行
  (6) 可行
  小技巧：若入栈的是一串数字例如12345，则21435是一个合法的出栈顺序，每一个元素i后比i小的都是降序排列（因为入栈的数字代表了进栈先后），24153不是合法的。
</details>

> This should be a callout
> 
> Can I fold it

### PPT

### ACM-OJ

#### 1080

#### 14151

#### 2422