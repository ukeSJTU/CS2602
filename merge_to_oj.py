import os
import re
import argparse
import platform
import subprocess
import shutil
from datetime import datetime


INCLUDE_DIR = "./include"
HOMEWORK_DIR = "./src/homework"
MERGE_MARKER = "// AUTO-GENERATED BY MERGE_TO_OJ SCRIPT"


def parse_includes(file_path, processed_files=None):
    """
    递归解析用户头文件并合并
    """
    if processed_files is None:
        processed_files = set()

    if file_path in processed_files:
        return ""  # 避免重复解析文件

    processed_files.add(file_path)

    with open(file_path, "r", encoding="utf-8") as file:
        lines = file.readlines()

    merged_code = []
    include_pattern = re.compile(r'#include\s+["<](.*?)[">]')

    for line in lines:
        match = include_pattern.match(line)
        if match:
            header = match.group(1)
            if header.endswith(".h"):  # 判断是头文件
                user_header_path = os.path.join(INCLUDE_DIR, header)
                if os.path.exists(user_header_path):
                    # 用户头文件：递归解析
                    merged_code.append(
                        parse_includes(user_header_path, processed_files)
                    )
                else:
                    # 系统头文件：直接保留
                    merged_code.append(line)
            else:
                merged_code.append(line)
        else:
            merged_code.append(line)

    return "".join(merged_code)


def generate_file_header(main_file_path):
    """
    生成文件头部标记
    """
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    return f"""{MERGE_MARKER}
// ORIGINAL FILE: {main_file_path}
// GENERATED TIME: {timestamp}
"""


def merge_cpp(main_file_path, output_file_path, force=False):
    """
    合并主文件及其依赖的头文件
    """
    if not os.path.exists(main_file_path):
        print(f"主文件 {main_file_path} 不存在！")
        return

    if os.path.exists(output_file_path) and not force:
        print(f"输出文件 {output_file_path} 已存在，使用 -f/--force 参数强制覆盖")
        return

    merged_code = parse_includes(main_file_path)
    header = generate_file_header(main_file_path)

    with open(output_file_path, "w", encoding="utf-8") as output_file:
        output_file.write(header + merged_code)

    print(f"合并完成！输出文件：{output_file_path}")


def format_code(file_path):
    """
    格式化代码
    """
    system = platform.system().lower()
    clang_format = "clang-format"

    # 检测平台与格式化工具
    if system == "windows":
        clang_format = "clang-format.exe"
    elif system == "linux" or system == "darwin":
        clang_format = "clang-format"

    # 检测是否有格式化工具
    if not shutil.which(clang_format):
        print("未检测到 clang-format 工具，跳过格式化")
        return

    # 检测 .clang-format 配置文件
    if os.path.exists(".clang-format"):
        print("检测到 .clang-format 配置文件，将使用该配置格式化代码")

    # 执行格式化
    try:
        subprocess.run([clang_format, "-i", file_path], check=True)
        print(f"格式化完成：{file_path}")
    except subprocess.CalledProcessError as e:
        print(f"格式化失败：{file_path}，错误信息：{e}")


def get_main_files(ids=None):
    """
    获取所有需要处理的 main.cpp 文件路径
    """
    if ids:
        return [
            os.path.join(HOMEWORK_DIR, f"{id_}/main.cpp")
            for id_ in ids
            if os.path.exists(os.path.join(HOMEWORK_DIR, f"{id_}/main.cpp"))
        ]
    else:
        # 默认查找所有 homework 下的 main.cpp 文件
        main_files = []
        for root, _, files in os.walk(HOMEWORK_DIR):
            for file in files:
                if file == "main.cpp":
                    main_files.append(os.path.join(root, file))
        return main_files


def is_generated_file(file_path):
    """
    检查文件是否是由脚本生成的
    """
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            first_line = f.readline().strip()
            return first_line == MERGE_MARKER
    except:
        return False


def find_generated_files():
    """
    查找所有由脚本生成的文件
    """
    generated_files = []
    for root, _, files in os.walk(HOMEWORK_DIR):
        for file in files:
            if file == "merged.cpp":
                file_path = os.path.join(root, file)
                if is_generated_file(file_path):
                    generated_files.append(file_path)
    return generated_files


def clean_generated_files(force=False):
    """
    清理由脚本生成的文件
    """
    generated_files = find_generated_files()

    if not generated_files:
        print("未找到任何由脚本生成的文件")
        return

    print("找到以下由脚本生成的文件：")
    for file in generated_files:
        print(f"  - {file}")

    if not force:
        response = input("\n确认要删除这些文件吗？(y/N): ").lower()
        if response != "y":
            print("操作已取消")
            return

    for file in generated_files:
        try:
            os.remove(file)
            print(f"已删除：{file}")
        except Exception as e:
            print(f"删除失败：{file}，错误信息：{e}")

    print("清理完成！")


def main():
    parser = argparse.ArgumentParser(description="自动合并 C++ 源文件及其依赖的头文件")
    parser.add_argument(
        "-i",
        "--ids",
        nargs="*",
        type=str,
        help="指定题目编号 ID（如 2498 2526），默认处理所有文件",
    )
    parser.add_argument(
        "-f", "--force", action="store_true", help="强制覆盖已存在的 merged.cpp 文件"
    )
    parser.add_argument("--no-format", action="store_true", help="不格式化输出文件")
    parser.add_argument("--clean", action="store_true", help="删除所有由脚本生成的文件")
    parser.add_argument(
        "--force-clean",
        action="store_true",
        help="删除所有由脚本生成的文件（不询问确认）",
    )
    args = parser.parse_args()

    # 处理清理命令
    if args.clean or args.force_clean:
        clean_generated_files(force=args.force_clean)
        return

    # 获取 main.cpp 文件列表
    main_files = get_main_files(args.ids)

    if not main_files:
        print("未找到任何需要处理的 main.cpp 文件")
        return

    # 处理每个文件
    for main_file in main_files:
        output_file = os.path.join(os.path.dirname(main_file), "merged.cpp")
        merge_cpp(main_file, output_file, force=args.force)

        if not args.no_format:
            format_code(output_file)


if __name__ == "__main__":
    main()
